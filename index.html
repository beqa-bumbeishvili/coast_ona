<!DOCTYPE html>
<meta charset="utf-8">
<style>
	.links line {
		stroke: #999;
		stroke-opacity: 0.6;
	}

	.nodes circle {
		stroke: #fff;
		stroke-width: 1.5px;
	}

	select {
		display: inline-block;
		height: 30px;
		width: 150px;
		padding: 2px 10px 2px 2px;
		margin: 2px;
		outline: none;
		color: #74646e;
		border: 1px solid #C8BFC4;
		border-radius: 4px;
		box-shadow: inset 1px 1px 2px #ddd8dc;
		background: #fff;
	}

	label, p {
		color: #645f5d;
	}
</style>

<body>
	<svg width="960" height="600"></svg>
	<script type="text/javascript" src="./d3.js"></script>
	<script>
		var config = {
			simulation: { strength: -100, distance: 120 },
			initialThreshold: 35,
			categoricalAttributes: ['position', 'department', 'experience'],
			ordinalAttributes: ['salary', 'tenure'],
			nodeSizes: { min: 5, max: 12 }
		}

		var svg = d3.select("svg"),
			width = +svg.attr("width"),
			height = +svg.attr("height");

		// Call zoom for svg container.
		svg.call(d3.zoom().on('zoom', zoomed));

		var color = d3.scaleOrdinal(d3.schemeCategory20);

		var simulation = d3.forceSimulation()
			.force("link", d3.forceLink())//Or to use names rather than indices: .id(function(d) { return d.id; }))
			.force("charge", d3.forceManyBody().strength([config.simulation.strength]).distanceMax([config.simulation.distance]))
			.force("center", d3.forceCenter(width / 2, height / 2));

		var container = svg.append('g');

		// Toggle for ego networks on click (below).
		var toggle = 0;
		var linkMaxConnection;
		var categoricalValues;
		var linkedByIndex;
		var distinctSources;
		var link;
		var node;

		d3.json("./employees.json", function (error, graph) {
			if (error) throw error;

			var categoricalValues = getAttributeValues(graph.nodes, config.categoricalAttributes);

			var distinctSources = ['any'].concat(Array.from(new Set(graph.link_connection_sources.map(function (d) { return d.source }))));

			setDataValues(graph);

			linkMaxConnection = linkWithMaxConnection(graph.link_connection_sources);

			// Make object of all neighboring nodes.
			linkedByIndex = {};
			graph.links.forEach(function (d) {
				linkedByIndex[d.source + ',' + d.target] = 1;
				linkedByIndex[d.target + ',' + d.source] = 1;
			});

			// Linear scale for degree centrality.
			var degreeSize = d3.scaleLinear()
				.domain([d3.min(graph.nodes, function (d) { return +d.salary; }), d3.max(graph.nodes, function (d) { return +d.salary; })])
				.range([config.nodeSizes.min, config.nodeSizes.max]);

			// Collision detection based on degree centrality.
			simulation.force("collide", d3.forceCollide().radius(function (d) { return degreeSize(+d.salary); }));

			var filteredLinks = graph.links.filter(d => linkMaxConnection[d.id].maxCount >= config.initialThreshold);

			link = container.append("g")
				.attr("class", "links")
				.selectAll("line")
				.data(filteredLinks, function (d) { return d.source + ", " + d.target; })
				.enter().append("line")
				.attr('class', 'link');

			node = container.append("g")
				.attr("class", "nodes")
				.selectAll("circle")
				.data(graph.nodes)
				.enter().append("circle")
				// Calculate degree centrality within JavaScript.
				//.attr("r", function(d, i) { count = 0; graph.links.forEach(function(l) { if (l.source == i || l.target == i) { count += 1;}; }); return size(count);})
				// Use degree centrality from NetworkX in json.
				.attr('r', function (d, i) { return degreeSize(+d.salary); })
				// Color by category
				.attr("fill", function (d) {
					let category = config.categoricalAttributes[0]
					let index = categoricalValues[category].findIndex(x => x == d[category]);
					return color(index);
				})
				.attr('class', 'node')
				// On click, toggle ego networks for the selected node.
				.on('click', function (d, i) {
					if (toggle == 0) {
						// Ternary operator restyles links and nodes if they are adjacent.
						d3.selectAll('.link').style('stroke-opacity', function (l) {
							return l.target == d || l.source == d ? 1 : 0.1;
						});
						d3.selectAll('.node').style('opacity', function (n) {
							return neighboring(d, n) ? 1 : 0.1;
						});
						d3.select(this).style('opacity', 1);
						toggle = 1;
					}
					else {
						// Restore nodes and links to normal opacity.
						d3.selectAll('.link').style('stroke-opacity', '0.6');
						d3.selectAll('.node').style('opacity', '1');
						toggle = 0;
					}
				})
				.call(d3.drag()
					.on("start", dragstarted)
					.on("drag", dragged)
					.on("end", dragended));

			node.append("title")
				.text(function (d) { return d.name; });

			simulation
				.nodes(graph.nodes)
				.on("tick", ticked);

			simulation.force("link")
				.links(filteredLinks);

			function ticked() {
				link
					.attr("x1", function (d) { return d.source.x; })
					.attr("y1", function (d) { return d.source.y; })
					.attr("x2", function (d) { return d.target.x; })
					.attr("y2", function (d) { return d.target.y; });

				node
					.attr("cx", function (d) { return d.x; })
					.attr("cy", function (d) { return d.y; });
			}

			// A slider (using only d3 and HTML5) that removes nodes below the input threshold.
			var slider = d3.select('body').append('p').text('Min number of interactions: ');

			slider.append('label')
				.attr('for', 'threshold')
				.text(config.initialThreshold);

			slider.append('input')
				.attr('type', 'range')
				.attr('min', d3.min(graph.links, function (d) { return d.weight; }))
				.attr('max', d3.max(graph.links, function (d) { return d.weight; }))
				.attr('value', config.initialThreshold)
				.attr('id', 'threshold')
				.style('width', '50%')
				.style('display', 'block')
				.on('input', function () {
					var threshold = this.value;
					d3.select('label').text(threshold);
					var source = d3.select('#interactionSourcesFilter').property('value');
					filterLinks(threshold, source, simulation, graph)
				});

			//create label
			var labels = node.append("text")
				.text(function (d) {
					return d.id;
				})
				.attr('x', 6)
				.attr('y', 3);

			var categoricalDropdownContainer = d3.select('body').append('div')

			categoricalDropdownContainer.append('label').text('ordinal filter - ')

			// A dropdown menu for ordinal filtering
			// Accounts for node collision.
			var categoricalDropdown = categoricalDropdownContainer
				.append('select')
				.attr('id', 'categoricalDropdown')
				.on('change', function () {
					var centrality = this.value;
					var centralitySize = d3.scaleLinear()
						.domain([d3.min(graph.nodes, function (d) { return +d[centrality]; }), d3.max(graph.nodes, function (d) { return +d[centrality]; })])
						.range([config.nodeSizes.min, config.nodeSizes.max]);
					node.transition().duration(200).attr('r', function (d) { return centralitySize(+d[centrality]); });
					// Recalculate collision detection based on selected centrality.
					simulation.force("collide", d3.forceCollide().radius(function (d) { return centralitySize(+d[centrality]); }));
					simulation.alphaTarget(0.1).restart();
				});

			categoricalDropdown.selectAll('option')
				.data(config.ordinalAttributes)
				.enter().append('option')
				.attr('value', d => d)
				.text(function (d) { return d; });

			var ordinalDropdownContainer = d3.select('body').append('div')

			ordinalDropdownContainer.append('label').text('categorical filter - ')

			// A dropdown menu for categorical filtering
			// Accounts for node collision.
			var ordinalDropdown = ordinalDropdownContainer
				.append('select')
				.attr('id', 'ordinalDropdown')
				.on('change', function () {
					var category = this.value
					container.selectAll('.node').transition().duration(200)
						.attr("fill", function (d) {
							let index = categoricalValues[category].findIndex(x => x == d[category]);
							return color(index);
						})
				});

			ordinalDropdown.selectAll('option')
				.data(config.categoricalAttributes)
				.enter().append('option')
				.attr('value', d => d)
				.text(function (d) { return d; });

			var sourcesContainer = d3.select('body').append('div')

			sourcesContainer.append('label').text('interaction source - ')

			// A dropdown menu for categorical filtering
			// Accounts for node collision.
			var interactionSourcesDropdown = sourcesContainer
				.append('select')
				.attr('id', 'interactionSourcesFilter')
				.on('change', function () {
					var source = this.value;

					var threshold = d3.select('#threshold').property('value');
					filterLinks(threshold, source, simulation, graph);
				});

			interactionSourcesDropdown.selectAll('option')
				.data(distinctSources)
				.enter().append('option')
				.attr('value', d => d)
				.text(function (d) { return d; });

			//filter links
			function filterLinks(threshold, source, simulation, graph) {
				// Find the links that are at or above the threshold.
				var newData = graph.links.filter(function (d) {
					if (source == 'any') return linkMaxConnection[d.id].maxCount >= threshold;
					return linkMaxConnection[d.id].maxCount >= threshold && linkMaxConnection[d.id].sources.includes(source);
				});

				// Data join with only those new links.
				link = link.data(newData, function (d) { return d.source + ', ' + d.target; });
				link.exit().remove();
				var linkEnter = link.enter().append('line').attr('class', 'link');
				link = linkEnter.merge(link);

				node = node.data(graph.nodes);

				// Restart simulation with new link data.
				simulation
					.nodes(graph.nodes).on('tick', ticked)
					.force("link").links(newData);

				simulation.alphaTarget(0.1).restart();
			}

		});

		function dragstarted(d) {
			if (!d3.event.active) simulation.alphaTarget(0.3).restart();
			d.fx = d.x;
			d.fy = d.y;
		}

		function dragged(d) {
			d.fx = d3.event.x;
			d.fy = d3.event.y;
		}

		function dragended(d) {
			if (!d3.event.active) simulation.alphaTarget(0);
			d.fx = null;
			d.fy = null;
		}

		// A function to test if two nodes are neighboring.
		function neighboring(a, b) {
			return linkedByIndex[a.index + ',' + b.index];
		}

		// Zooming function translates the size of the svg container.
		function zoomed() {
			container.attr("transform", "translate(" + d3.event.transform.x + ", " + d3.event.transform.y + ") scale(" + d3.event.transform.k + ")");
		}

		function setDataValues(graph) {
			graph.links.forEach(function (d) {
				d.source = d.e1
				d.target = d.e2
			})
		}

		//calculate max interactions count for each link 
		function linkWithMaxConnection(connections) {
			var temp = {};

			connections.forEach(element => {
				var link_id = element.link_id;

				if (temp[link_id] == undefined) {
					temp[link_id] = {
						maxCount: parseInt(element.interaction_count),
						sources: parseInt(element.interaction_count) > 0 ? [element.source] : []
					}
				}
				else {
					var max = temp[link_id].maxCount > parseInt(element.interaction_count) ? temp[link_id].maxCount : parseInt(element.interaction_count);
					let count = parseInt(element.interaction_count);
					temp[link_id] = {
						maxCount: max,
						sources: count > 0 ? temp[link_id].sources : temp[link_id].sources.concat([element.source])
					}
				}
			});

			return temp;
		}

		//calculate values for each categories
		function getAttributeValues(nodes, categoricalAttributes) {
			var temp = {}
			categoricalAttributes.forEach(function (keyName) {
				temp[keyName] = Array.from(new Set(nodes.map(function (d) { return d[keyName] })));
			});

			return temp;
		}

	</script>
</body>